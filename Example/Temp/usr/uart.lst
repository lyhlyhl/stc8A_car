C51 COMPILER V9.53.0.0   UART                                                              07/22/2020 23:15:42 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\uart.obj
COMPILER INVOKED BY: F:\MDK5\C51\BIN\C51.EXE ..\hardware\UART\uart.c LARGE OMF2 OPTIMIZE(2,SPEED) BROWSE INCDIR(..\hardw
                    -are\delay;..\hardware\IIC;..\hardware\OLED;..\hardware\ADC;..\hardware\Mpu6050;..\hardware\KEY;..\hardware\LED;..\hardwa
                    -re\PWM;..\hardware\pca;..\hardware\timer;..\hardware\PID;..\hardware\CCD;..\hardware\UART;..\hardware\Motor) DEBUG PRINT
                    -(.\uart.lst) TABS(3) OBJECT(.\uart.obj)

line level    source

   1          #include "uart.h"
   2          
   3          extern int dat_set;
   4          extern int uflag;
   5          
   6          struct recstr_struct //接受的字符结构体
   7          {
   8              char *p_head;
   9              char *p_now;
  10              char recstr[20];
  11          };
  12          struct recstr_struct rec;
  13          u8 c_variable[10] = "1234", c_data[10];
  14          u8 datee[10] = "adc";
  15          void rec_struct_init() //结构体初始化赋值
  16          {
  17   1          rec.p_head = rec.recstr;
  18   1          rec.p_now = rec.recstr;
  19   1      }
  20          
  21          void uart_putchar(u8 dat) //发送一个字节
  22          {
  23   1          SBUF = dat;
  24   1          while (!TI)
  25   1              ;
  26   1          TI = 0;
  27   1      }
  28          
  29          void uart_putstr(u8 *str) //发送一个字符串
  30          {
  31   1          while (*str)
  32   1          {
  33   2              uart_putchar(*str++);
  34   2          }
  35   1      }
  36          
  37          void uart_get_data() //获取数据添加到字符串中
  38          {
  39   1          u8 rec_dat;
  40   1          rec_dat = SBUF;
  41   1          uart_rec_data_add(rec_dat);
  42   1      }
  43          void uart_rec_data_add(u8 dat) //识别通信协议
  44          {
  45   1          if (dat == '+') //第一位为加号
  46   1          {
  47   2              rec.p_now = rec.recstr; //把当前的字符串指针指向头指针
  48   2          }
  49   1          else if (dat == '*') //如果最后一位为星号
  50   1          {
  51   2              *rec.p_now = '\0'; //最后添加结束符
  52   2                                 //        uart_putstr(rec.recstr);
C51 COMPILER V9.53.0.0   UART                                                              07/22/2020 23:15:42 PAGE 2   

  53   2              //spilt_str();       //直接分割字符串得到结果
  54   2                                 //        uart_putstr(c_variable); //方便调试显示用
  55   2                                 //        uart_putchar(' ');
  56   2                                 //        uart_putstr(c_data);
  57   2               uflag = 1;
  58   2          }
  59   1          else
  60   1          {
  61   2              *rec.p_now = dat;
  62   2              rec.p_now++;
  63   2          }
  64   1      }
  65          
  66          void spilt_str() // 分割字符串
  67          {
  68   1          u8 i, Possem, j;
  69   1         
  70   1          for (i = 0; rec.recstr[i] != '\0'; i++) //识别字符串中间的冒号的位置
  71   1          {
  72   2              if (rec.recstr[i] == ':')
  73   2              {
  74   3                  Possem = i;
  75   3                  break;
  76   3              }
  77   2          }
  78   1          for (j = 0; j < Possem; j++) //分别赋值给俩个字符串
  79   1          {
  80   2              c_variable[j] = rec.recstr[j];
  81   2          }
  82   1          c_variable[j] = '\0';
  83   1      
  84   1          for (i = Possem + 1; i <= strlen(rec.recstr); i++)
  85   1          {
  86   2              c_data[i - Possem - 1] = rec.recstr[i];
  87   2          }
  88   1          c_data[i - Possem - 1] = '\0';
  89   1         
  90   1          if (str_cmp_fuck(c_variable, "adc")) //开始识别
  91   1          {
  92   2              dat_set = atoi(c_data);
  93   2          }
  94   1      }
  95          
  96          char str_cmp_fuck(u8 *s_a, u8 *s_b)
  97          {
  98   1          int p, q, i, t = 0;
  99   1          p = strlen(s_a);
 100   1          q = strlen(s_b);
 101   1         
 102   1          for (i = 0; s_a[i] != '\0' && s_b[i] != '\0'; i++)
 103   1          {
 104   2              if (s_a[i] > s_b[i])
 105   2              {
 106   3                  t = 1;
 107   3                  return t;
 108   3              }
 109   2              if (s_a[i] < s_b[i])
 110   2              {
 111   3                  t = -1;
 112   3                  return t;
 113   3              }
 114   2          }
C51 COMPILER V9.53.0.0   UART                                                              07/22/2020 23:15:42 PAGE 3   

 115   1          if (t == 0)
 116   1          {
 117   2              if (p > q)
 118   2                  t = 1;
 119   2              if (p < q)
 120   2                  t = -1;
 121   2          }
 122   1          return t;
 123   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    962    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =     56      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
